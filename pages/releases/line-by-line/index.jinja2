{% extends '../../common/jinja/layouts/base.jinja2' %}

{% block head %}
  <meta name="description"
        content="Слушайте бесплатно альбом &quot;построчно&quot; анти-музыкального анти-коллектива &quot;потерпевшие&quot;. Альбом доступен на всех площадках.">
  <meta property="og:title" content="потерпевшие - построчно">
  <meta property="og:description" content="слушать без смс и регистрации">
  <meta property="og:image" content="https://terpevshie.ru/releases/line-by-line/cover.webp">
  <meta property="og:url" content="https://terpevshie.ru/releases/line-by-line">
  <meta property="og:type" content="website">
  {% include '../../common/jinja/includes/font_old_standard.html' %}
  {% include '../../common/jinja/includes/favicon_tags.html' %}
{% endblock %}

{% set constants = {
  "cover_img_padding_in_px": 5,
  "cover_img_rounding_in_px": 10,
} %}

{# Components #}
{% import '../../common/jinja/components/navbar.jinja2' as navbar %}

{% block content %}
  {{ navbar.html() }}
  <main style="width: 100%; display: flex; justify-content: center; align-items: center;">
    <div style="padding: 4.2rem 2rem;">
      <div id="container" style="position: relative; z-index: 10; padding: {{ constants.cover_img_padding_in_px }}px">
        <img
          fetchpriority="high"
          id="album-img"
          class="hover-scale"
          src="cover.webp"
          alt="обложка альбома"
          onerror="this.alt='не удалось загрузить изображение...';"
        >
      </div>
    </div>
  </main>
{% endblock %}

{% block script %}
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <script>
    {% set cover_img_extra_size = constants.cover_img_padding_in_px * 2 %}
  
    let img;
    let glitchTime = 0;
    let nextGlitch = 0;

    const coverImgEl = document.getElementById('album-img')
    let canvasEl;

    function createSmoothValue(min, max, periodMs, phase = 0) {
      // min, max — границы
      // periodMs — полный цикл (в миллисекундах)
      // phase — сдвиг по времени (0..1), чтобы сделать несколько значений с разной фазой

      return {
        get() {
          const t = (performance.now() % periodMs) / periodMs;
          const easedT = 0.5 + 0.5 * Math.sin(2 * Math.PI * (t + phase));
          return min + easedT * (max - min);
        }
      };
    }

    function createRoundedMask(w, h, r) {
      let mask = createGraphics(w, h);
      mask.noStroke();
      mask.fill(255);
      mask.rect(0, 0, w, h, r);
      return mask;
    }

    function preload() {
      let roundedMask;
      img = loadImage("cover.webp", () => {
        roundedMask = createRoundedMask(
          img.width,
          img.height,
          {{ constants.cover_img_rounding_in_px }},
        );
        img.mask(roundedMask);
        coverImgEl.style.opacity = 0;
      });
    }

    function planNextGlitch() {
      nextGlitch = millis() + random(1000, random(4000, 13000));
    }

    function setup() {
      const imgBounds = coverImgEl.getBoundingClientRect();
      canvasEl = createCanvas(
        imgBounds.width + {{ cover_img_extra_size }},
        imgBounds.height + {{ cover_img_extra_size }},
      );
      canvasEl.parent('#container');
      imageMode(CENTER);
      noSmooth();
      planNextGlitch();
    }

    let deformFactor = createSmoothValue(2, 5, 11000);

    function drawCover(imgWidth, imgHeight) {
      let cx = width / 2;
      let cy = height / 2;

      let yStep = 2;
      for (let y = 0; y < imgHeight; y += yStep) {
        let offset = (noise(y * 0.02, millis() * 0.0005) - 0.5) * deformFactor.get();
        image(
          img,
          cx + offset,
          cy - imgHeight / 2 + y,
          imgWidth,
          yStep,
          0,
          (y / imgHeight) * img.height,
          img.width,
          (yStep / imgHeight) * img.height
        );
      }
    }

    let glitchFactor = createSmoothValue(1, 10, 20000)

    function drawGlitch(imgWidth, imgHeight) {
      let cx = width / 2;
      let cy = height / 2;

      push();
      imageMode(CORNER);
      translate(cx - imgWidth / 2, cy - imgHeight / 2);
      tint(255, random(50, 255));

      const count = random(5, 30);
      for (let i = 0; i < count; i++) {
        let swSrc = random(10, 50 * glitchFactor.get());
        let shSrc = random(5, 20 * glitchFactor.get());
        let sx = random(img.width - swSrc);
        let sy = random(img.height - shSrc);

        let sw = (swSrc / img.width) * imgWidth;
        let sh = (shSrc / img.height) * imgHeight;
        let dx = (sx / img.width) * imgWidth + random(-5, 5);
        let dy = (sy / img.height) * imgHeight + random(-5, 5);

        image(img, dx, dy, sw, sh, sx, sy, swSrc, shSrc);
      }

      pop();
      noTint();
    }

    function drawCutGlitch(imgWidth, imgHeight) {
      let cx = width / 2;
      let cy = height / 2;
      push();
      imageMode(CORNER);
      translate(cx - imgWidth / 2, cy - imgHeight / 2);

      let stripsCount = floor(random(2, 6));
      for (let i = 0; i < stripsCount; i++) {
        let stripHeight = random(imgHeight * 0.05, imgHeight * 0.15);
        let y = random(0, imgHeight - stripHeight);
        let xOffset = random(-15, 15);

        // копируем часть изображения со сдвигом по X
        copy(0, y, imgWidth, stripHeight, xOffset, y, imgWidth, stripHeight);
      }
      pop();
    }

    const RGBShiftIntensityFactor = createSmoothValue(40, 100, 24000)

    {% set rgb_shift_amount = 4 %}
    const shiftRFactor = createSmoothValue(
      {{ rgb_shift_amount * 0.5 }},
      {{ rgb_shift_amount }},
      4000,
      0,
    );
    const shiftGFactor = createSmoothValue(
      {{ rgb_shift_amount * 0.5 }},
      {{ rgb_shift_amount }},
      4000,
      0.33
    );
    const shiftBFactor = createSmoothValue(
      {{ rgb_shift_amount * 0.5 }},
      {{ rgb_shift_amount }},
      4000,
      0.66
    );

    // RGB сдвиг — отдельно рисуем 3 слоя с цветовым сдвигом и прозрачностью
    function drawRGBShift(imgWidth, imgHeight) {
      let cx = width / 2;
      let cy = height / 2;

      push();
      imageMode(CENTER);
      blendMode(SCREEN);

      const intensity = RGBShiftIntensityFactor.get()

      tint(255, 0, 0, intensity);
      image(img, cx - shiftRFactor.get(), cy, imgWidth, imgHeight);

      tint(0, 255, 0, intensity);
      image(img, cx, cy + shiftGFactor.get(), imgWidth, imgHeight);

      tint(0, 0, 255, intensity);
      image(img, cx + shiftBFactor.get(), cy, imgWidth, imgHeight);

      pop();

      blendMode(BLEND);
      noTint();
    }

    function draw() {
      // Пусть глитч иногда "зависает"?
      // if (Math.random() < 0.05) {
      clear();
      // }

      const imgBounds = coverImgEl.getBoundingClientRect();
      const imgWidth = imgBounds.width;
      const imgHeight = imgBounds.height;

      drawCover(imgWidth, imgHeight);

      if (millis() < glitchTime) {
        Math.random() > 0.2 ? drawGlitch(imgWidth, imgHeight) : drawCutGlitch(imgWidth, imgHeight);
      }

      if (millis() > nextGlitch) {
        glitchTime = millis() + random(300, 800); // длительность глитча
        planNextGlitch();
      }

      // Рисуем RGB сдвиг с небольшой прозрачностью (создает размытие цвета)
      drawRGBShift(imgWidth, imgHeight);
    }

    function windowResized() {
      const imgBounds = coverImgEl.getBoundingClientRect()
      resizeCanvas(
        imgBounds.width + {{ cover_img_extra_size }},
        imgBounds.height + {{ cover_img_extra_size }},
      );
    }
  </script>
{% endblock %}

{% block style %}
  <link rel="stylesheet" href="/common/css/minireset.css">
  <style>
    {% include '../../common/jinja/includes/view_transition.css' %}

    .font-regular {
      font-family: "Old Standard TT", serif;
      font-weight: 400;
      font-style: normal;
    }

    {{ navbar.styles() }}

    body {
      margin: 0;
      background: #221a15;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      overflow: hidden;
    }

    #album-img {
      aspect-ratio: 1 / 1;
      width: 100%;
      max-width: 500px;
      max-height: 500px;
      border-radius: {{ constants.cover_img_rounding_in_px }}px; /* todo 1rem */
    }

    canvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
    }
  </style>
{% endblock %}