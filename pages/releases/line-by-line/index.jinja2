{% extends '../../common/jinja/layouts/base.jinja2' %}

{% block title %}
  потерпевшие - построчно
{% endblock %}

{% block head %}
  <meta name="description"
        content="Слушайте бесплатно альбом &quot;построчно&quot; анти-музыкального анти-коллектива &quot;потерпевшие&quot;. Альбом доступен на всех площадках.">
  <meta property="og:title" content="потерпевшие - построчно">
  <meta property="og:description" content="слушать без смс и регистрации">
  <meta property="og:image" content="https://terpevshie.ru/releases/line-by-line/cover.webp">
  <meta property="og:url" content="https://terpevshie.ru/releases/line-by-line">
  <meta property="og:type" content="website">
  {% include '../../common/jinja/includes/font_old_standard.html' %}
  {% include '../../common/jinja/includes/favicon_tags.html' %}
{% endblock %}

{% set constants = {
  "cover_img_padding_in_px": 5,
  "cover_img_rounding_in_px": 16,
  "bg_img_scale": 1.15,
} %}

{# Components #}
{% import '../../common/jinja/components/navbar.jinja2' as navbar %}
{% import '../../common/jinja/components/links.jinja2' as links %}

{% block content %}
  <div id="background-image"></div>
  <div id="background-color-overlay"></div>
  <div id="background-noise"></div>
  <div id="background-rgb-shift"></div>

  {{ navbar.html() }}

  <main class="font-regular">
    <div id="release-card">
      <h1>потерпевшие - построчно</h1>
      <div id="cover-img-container">
        <img
          fetchpriority="high"
          id="cover-img"
          class="hover-scale"
          src="cover.webp"
          alt="обложка альбома"
          onerror="this.alt='не удалось загрузить изображение...';"
        >
      </div>

      {{ links.html([
        {"title": "яндекс", "src": "https://music.yandex.ru/album/37683861"},
        {"title": "vk", "src": "https://vk.com/wall-220989745_45"},
        {"title": "spotify", "src": "https://open.spotify.com/album/7DYTpsjFViG1secFxkDdu2"},
        {"title": "apple", "src": "https://itunes.apple.com/album/id/1831075175"},
        {"title": "youtube", "src": "https://www.youtube.com/watch?v=4Tt6tuld5T0&list=OLAK5uy_lOAioxBliQKKpWQB0pFxv0Jng0UNOCP5o"},
      ]) }}

      <div id="tracklist">
        {% set tracks = [
          {"title": "веришь", "src": "/releases/line-by-line/audio/веришь.mp3"},
          {"title": "решето", "src": "/releases/line-by-line/audio/решето.mp3"},
          {"title": "вымысел", "src": "/releases/line-by-line/audio/вымысел.mp3"},
          {"title": "память", "src": "/releases/line-by-line/audio/память.mp3"},
          {"title": "когда", "src": "/releases/line-by-line/audio/когда.mp3"},
        ] %}

        {% for track in tracks %}
          <div class="track" data-src="{{ track.src }}">
            <span class="title">{{ track.title }}</span>
            <div class="controls">
              <button class="play-btn">
                <!-- play icon -->
                <svg class="icon icon-play" viewBox="0 0 24 24" width="20" height="20" aria-hidden="true">
                  <polygon points="5,3 19,12 5,21" fill="currentColor"></polygon>
                </svg>

                <!-- pause icon -->
                <svg class="icon icon-pause" viewBox="0 0 24 24" width="20" height="20" aria-hidden="true">
                  <rect x="6" y="4" width="4" height="16" fill="currentColor"></rect>
                  <rect x="14" y="4" width="4" height="16" fill="currentColor"></rect>
                </svg>
              </button>
              <div class="progress">
                <canvas class="progress-noise"></canvas>
                <div class="progress-bar"></div>
              </div>
            </div>
          </div>
        {% endfor %}
      </div>
    </div>
  </main>
{% endblock %}

{% block script %}
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <script>
    {% set cover_img_extra_size = constants.cover_img_padding_in_px * 2 %}

    let img;
    let glitchTime = 0;
    let nextGlitch = 0;

    let canvasStarted = false;

    const coverImgEl = document.getElementById('cover-img')
    let canvasEl;

    function createSmoothValue(min, max, periodMs, phase = 0) {
      // min, max — границы
      // periodMs — полный цикл (в миллисекундах)
      // phase — сдвиг по времени (0..1), чтобы сделать несколько значений с разной фазой

      return {
        get() {
          const t = (performance.now() % periodMs) / periodMs;
          const easedT = 0.5 + 0.5 * Math.sin(2 * Math.PI * (t + phase));
          return min + easedT * (max - min);
        }
      };
    }

    function createRoundedMask(w, h, r) {
      let mask = createGraphics(w, h);
      mask.noStroke();
      mask.fill(255);
      mask.rect(0, 0, w, h, r);
      return mask;
    }

    function preload() {
      let roundedMask;
      img = loadImage("cover.webp", () => {
        roundedMask = createRoundedMask(
          img.width,
          img.height,
          {{ constants.cover_img_rounding_in_px }},
        );
        img.mask(roundedMask);
      });
    }

    function planNextGlitch() {
      nextGlitch = millis() + random(1000, random(4000, 13000));
    }

    function setup() {
      const imgBounds = coverImgEl.getBoundingClientRect();
      canvasEl = createCanvas(
        imgBounds.width + {{ cover_img_extra_size }},
        imgBounds.height + {{ cover_img_extra_size }},
      );
      canvasEl.parent('#cover-img-container');
      imageMode(CENTER);
      noSmooth();
      planNextGlitch();
    }

    let deformFactor = createSmoothValue(2, 5, 11000);

    function drawCover(imgWidth, imgHeight) {
      let cx = width / 2;
      let cy = height / 2;

      let yStep = 2;
      for (let y = 0; y < imgHeight; y += yStep) {
        let offset = (noise(y * 0.02, millis() * 0.0005) - 0.5) * deformFactor.get();
        image(
          img,
          cx + offset,
          cy - imgHeight / 2 + y,
          imgWidth,
          yStep,
          0,
          (y / imgHeight) * img.height,
          img.width,
          (yStep / imgHeight) * img.height
        );
      }
    }

    let glitchFactor = createSmoothValue(1, 10, 20000)

    function drawGlitch(imgWidth, imgHeight) {
      let cx = width / 2;
      let cy = height / 2;

      push();
      imageMode(CORNER);
      translate(cx - imgWidth / 2, cy - imgHeight / 2);
      tint(255, random(50, 255));

      const count = random(5, 30);
      for (let i = 0; i < count; i++) {
        let swSrc = random(10, 50 * glitchFactor.get());
        let shSrc = random(5, 20 * glitchFactor.get());
        let sx = random(img.width - swSrc);
        let sy = random(img.height - shSrc);

        let sw = (swSrc / img.width) * imgWidth;
        let sh = (shSrc / img.height) * imgHeight;
        let dx = (sx / img.width) * imgWidth + random(-5, 5);
        let dy = (sy / img.height) * imgHeight + random(-5, 5);

        image(img, dx, dy, sw, sh, sx, sy, swSrc, shSrc);
      }

      pop();
      noTint();
    }

    function drawCutGlitch(imgWidth, imgHeight) {
      let cx = width / 2;
      let cy = height / 2;
      push();
      imageMode(CORNER);
      translate(cx - imgWidth / 2, cy - imgHeight / 2);

      let stripsCount = floor(random(2, 6));
      for (let i = 0; i < stripsCount; i++) {
        let stripHeight = random(imgHeight * 0.05, imgHeight * 0.15);
        let y = random(0, imgHeight - stripHeight);
        let xOffset = random(-15, 15);

        // копируем часть изображения со сдвигом по X
        copy(0, y, imgWidth, stripHeight, xOffset, y, imgWidth, stripHeight);
      }
      pop();
    }

    const RGBShiftOpacityFactor = createSmoothValue(10, 40, 24000)
    let rgbShiftOpacity = 0;  // Для fade-in

    {% set rgb_shift_amount = 3 %}
    const shiftRFactor = createSmoothValue(
      {{ rgb_shift_amount * 0.5 }},
      {{ rgb_shift_amount }},
      4000,
      0,
    );
    const shiftGFactor = createSmoothValue(
      {{ rgb_shift_amount * 0.5 }},
      {{ rgb_shift_amount }},
      4000,
      0.33
    );
    const shiftBFactor = createSmoothValue(
      {{ rgb_shift_amount * 0.5 }},
      {{ rgb_shift_amount }},
      4000,
      0.66
    );

    // RGB сдвиг — отдельно рисуем 3 слоя с цветовым сдвигом и прозрачностью
    function drawRGBShift(imgWidth, imgHeight) {
      rgbShiftOpacity = Math.min(1, rgbShiftOpacity + 0.01)

      let cx = width / 2;
      let cy = height / 2;

      push();
      imageMode(CENTER);
      blendMode(SCREEN);

      const opacity = RGBShiftOpacityFactor.get() * rgbShiftOpacity

      tint(255, 0, 0, opacity);
      image(img, cx - shiftRFactor.get(), cy, imgWidth, imgHeight);

      tint(0, 255, 0, opacity);
      image(img, cx, cy + shiftGFactor.get(), imgWidth, imgHeight);

      tint(0, 0, 255, opacity);
      image(img, cx + shiftBFactor.get(), cy, imgWidth, imgHeight);

      pop();

      blendMode(BLEND);
      noTint();
    }

    let rgbShiftStarted = false;
    setTimeout(() => rgbShiftStarted = true, 1500)

    function draw() {
      if (!canvasStarted) {
        canvasStarted = true;
        coverImgEl.style.opacity = 0;
      }

      // Пусть глитч иногда "зависает"?
      // if (Math.random() < 0.05) {
      clear();
      // }

      const imgBounds = coverImgEl.getBoundingClientRect();
      const imgWidth = imgBounds.width;
      const imgHeight = imgBounds.height;

      drawCover(imgWidth, imgHeight);

      if (millis() < glitchTime) {
        Math.random() > 0.2 ? drawGlitch(imgWidth, imgHeight) : drawCutGlitch(imgWidth, imgHeight);
      }

      if (millis() > nextGlitch) {
        glitchTime = millis() + random(300, 800); // длительность глитча
        planNextGlitch();
      }

      if (rgbShiftStarted) {
        drawRGBShift(imgWidth, imgHeight);
      }
    }

    function windowResized() {
      const imgBounds = coverImgEl.getBoundingClientRect()
      resizeCanvas(
        imgBounds.width + {{ cover_img_extra_size }},
        imgBounds.height + {{ cover_img_extra_size }},
      );
    }

    /* BACKGROUND */

    let mouseX = 0, mouseY = 0;
    let targetX = 0, targetY = 0;

    document.addEventListener('mousemove', e => {
      mouseX = (e.clientX / window.innerWidth - 0.5) * -2; // -1..1
      mouseY = (e.clientY / window.innerHeight - 0.5) * 2;
    });

    const bgEl = document.querySelector('#background-image');
    const noiseEl = document.querySelector('#background-noise');
    const rgbShiftEl = document.querySelector('#background-rgb-shift');

    function animateBackground() {
      const t = performance.now()

      // Медленно интерполируем targetX/Y к mouseX/Y (инерция)
      targetX += (mouseX - targetX) * 0.02;
      targetY += (mouseY - targetY) * 0.02;

      const parallaxX = targetX * 30; // px
      const parallaxY = targetY * 30; // px


      const scale = {{ constants.bg_img_scale }} + Math.sin(t / 4000) * 0.015;
      bgEl.style.transform = `scale(${scale}, -${scale}) translate(${parallaxX}px, ${parallaxY}px)`;

      // Движение шума
      {#noiseEl.style.backgroundPosition = `${Math.random() * 100}% ${Math.random() * 100}%`;#}

      // Лёгкое цветовое смещение
      const shiftX = Math.sin(t / 2000) * 50; // пиксели
      rgbShiftEl.style.transform = ` scale({{ constants.bg_img_scale }}, -{{ constants.bg_img_scale }}) translateX(${shiftX}px)`;

      // Цветовой перелив через hue-rotate
      {#const hue = (t / 5) % 360;#}
      {#rgbShiftEl.style.filter = `blur(12px) contrast(1.05) saturate(1.1) hue-rotate(${hue}deg)`;#}

      requestAnimationFrame(animateBackground);
    }

    animateBackground();

    window.addEventListener('load', () => {
      const img = new Image();
      img.src = getComputedStyle(bgEl).backgroundImage.replace(/url\((['"])?(.*?)\1\)/, '$2');
      img.onload = () => {
        setTimeout(() => {
          bgEl.classList.add('visible');
        }, 200);
      };
    });

    /* AUDIO */

    const tracks = document.querySelectorAll('.track');
    let currentAudio = null;
    let currentTrackIndex = -1;

    tracks.forEach((track, index) => {
      const btn = track.querySelector('.play-btn');
      const progressBar = track.querySelector('.progress-bar');
      const noiseCanvas = track.querySelector('.progress-noise');
      const ctx = noiseCanvas.getContext('2d');
      const src = track.dataset.src;
      const audio = new Audio(src);

      // Начальное состояние
      track.classList.add('paused');

      function drawNoise() {
        const w = noiseCanvas.width;
        const h = noiseCanvas.height;

        if (w === 0 || h === 0) {
          ctx.clearRect(0, 0, noiseCanvas.width, noiseCanvas.height);
          return;
        }

        const imageData = ctx.createImageData(w, h);
        const data = imageData.data;

        for (let i = 0; i < data.length; i += 4) {
          const v = Math.floor(Math.random() * 255);
          data[i] = v;
          data[i + 1] = v;
          data[i + 2] = v;
          data[i + 3] = 30;
        }

        ctx.putImageData(imageData, 0, 0);
      }

      btn.addEventListener('click', () => {
        if (currentAudio && currentAudio !== audio) {
          currentAudio.pause();
          currentAudio.currentTime = 0;
          tracks.forEach(t => {
            t.classList.remove('playing');
            t.classList.add('paused');
          });
        }

        if (audio.paused) {
          audio.play();
          track.classList.remove('paused');
          track.classList.add('playing');
          currentAudio = audio;
          currentTrackIndex = index;
        } else {
          audio.pause();
          track.classList.remove('playing');
          track.classList.add('paused');
        }
      });

      audio.addEventListener('timeupdate', () => {
        const progress = (audio.currentTime / audio.duration) * 100 || 0;
        progressBar.style.width = `${progress}%`;

        let progressPx = noiseCanvas.parentElement.offsetWidth * (progress / 100);
        if (progressPx < 1) progressPx = 1;

        noiseCanvas.style.width = progressPx + 'px';
        noiseCanvas.width = progressPx;
        noiseCanvas.height = progressBar.offsetHeight;

        drawNoise();
      });

      audio.addEventListener('ended', () => {
        progressBar.style.width = '0%';
        noiseCanvas.style.width = '0px';
        noiseCanvas.width = 0;
        track.classList.remove('playing');
        track.classList.add('paused');

        // Автоматический переход к следующему треку (циклично)
        let nextIndex = (index + 1) % tracks.length;
        const nextTrack = tracks[nextIndex];
        const nextBtn = nextTrack.querySelector('.play-btn');
        nextBtn.click();
      });

      window.addEventListener('resize', () => {
        const progress = (audio.currentTime / audio.duration) * 100 || 0;
        let progressPx = noiseCanvas.parentElement.offsetWidth * (progress / 100);
        if (progressPx < 1) progressPx = 1;

        noiseCanvas.style.width = progressPx + 'px';
        noiseCanvas.width = progressPx;
        noiseCanvas.height = progressBar.offsetHeight;

        drawNoise();
      });
    });
  </script>
{% endblock %}

{% block style %}
  <link rel="stylesheet" href="/common/css/minireset.css">
  <style>
    {% include '../../common/jinja/includes/view_transition.css' %}

    .font-regular {
      font-family: "Old Standard TT", serif;
      font-weight: 400;
      font-style: normal;
    }

    {{ navbar.styles() }}
    {{ links.styles() }}

    body {
      margin: 0;
      background: #7a6559;
      min-height: 100vh;
    }

    body::after {
      content: '';
      position: fixed;
      inset: 0;
      background: radial-gradient(ellipse at center, rgba(0, 0, 0, 0) 65%, rgba(0, 0, 0, 0.2) 100%);
      z-index: 0;
      pointer-events: none;
    }

    #background-image {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;

      background-image: url('bg.webp');
      background-size: cover;
      background-position: center;

      opacity: 0;
      filter: blur(10px) brightness(0.8);
      transform: scale({{ constants.bg_img_scale }}, -{{ constants.bg_img_scale }});
      transition: opacity 3s ease;

      z-index: -3;
      pointer-events: none;
      will-change: opacity, transform, filter;
    }

    #background-image.visible {
      opacity: 0.5;
    }

    #background-color-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background-color: rgba(251, 199, 153, 0.2);
      mix-blend-mode: overlay;

      z-index: -2;
      pointer-events: none;
    }

    #background-noise {
      position: fixed;
      inset: 0;
      background-image: url('noise.webp');
      background-size: cover;
      opacity: 0.03;
      transform: scale(1.4);
      mix-blend-mode: soft-light;
      z-index: -2;
      pointer-events: none;
    }

    #background-rgb-shift {
      position: fixed;
      inset: 0;
      background-image: url('bg.webp');
      background-size: cover;
      background-position: center;
      filter: blur(12px) contrast(1.05) saturate(1.1);
      mix-blend-mode: screen;
      opacity: 0.2;
      transform: scale({{ constants.bg_img_scale }}, -{{ constants.bg_img_scale }}) translateX(0);
      z-index: -1;
      pointer-events: none;
    }

    main {
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #release-card {
      color: #e4dad2;
      margin: 6rem 2rem;
      max-width: 600px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1.5rem;
    }

    #release-card h1 {
      margin: 0 1rem;
      font-size: 2.5rem;
    }

    #cover-img-container {
      position: relative;
      z-index: 5;
      padding: {{ constants.cover_img_padding_in_px }}px
    }

    #cover-img {
      aspect-ratio: 1 / 1;
      width: 100%;
      max-width: 500px;
      max-height: 500px;
      border-radius: {{ constants.cover_img_rounding_in_px }}px; /* todo 1rem */
    }

    #p5_loading {
      display: none;
    }

    canvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
    }

    #tracklist {
      width: 100%;
      max-width: 500px;
      margin: 1rem auto 0;
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    {% set track_bg_rgb = "99, 65, 44" %}

    .track {
      display: flex;
      flex-direction: column;
      background: rgba({{ track_bg_rgb }}, 0.25);
      padding: 1rem;
      border-radius: {{ constants.cover_img_rounding_in_px }}px;
      backdrop-filter: blur(4px);
      box-shadow: 0 0 10px rgba(41, 27, 18, 0.05);
      transition: transform 0.3s ease, background 0.5s ease;
    }

    .track.playing {
      transform: translateY(-2px);
      background: rgba({{ track_bg_rgb }}, 0.5);
      box-shadow: 0 0 30px rgba(251, 199, 153, 0.2);
    }

    .track:not(.playing):hover {
      transform: translateY(-2px);
      background: rgba({{ track_bg_rgb }}, 0.35);
    }

    .track .controls {
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }

    .play-btn {
      position: relative;
      background: none;
      border: none;
      height: 1.5rem;
      width: 2rem;
      color: #e4dad2;
      font-size: 1.2rem;
      cursor: pointer;
    }

    .play-btn .icon {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      display: block;
      pointer-events: none;
    }

    .play-btn .icon-pause, .track.playing .play-btn .icon-play {
      opacity: 0;
      transform: translate(-50%, -50%) scale(0.8);
      transition: opacity .18s ease, transform .18s ease;
    }

    .track.playing .play-btn .icon-pause {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1);
    }

    .play-btn:hover {
      filter: none;
    }

    .title {
      font-size: 1rem;
      margin-bottom: 0.5rem;
    }

    .progress {
      position: relative;
      width: 100%;
      height: 6px;
      background: rgba(255, 255, 255, 0.15);
      overflow: hidden;
      border-radius: 3px;
    }

    .progress-bar {
      height: 100%;
      width: 0;
      background: linear-gradient(90deg, rgba(251, 199, 153, 0.7), rgba(255, 255, 255, 0.3));
      transition: width 0.1s linear;
    }

    .progress-noise {
      position: absolute;
      top: 0;
      left: 0;
      height: 100%;
      width: 0;
      pointer-events: none;
      z-index: 2;
    }
  </style>
{% endblock %}